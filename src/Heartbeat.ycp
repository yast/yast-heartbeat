/**
 * File:	modules/Heartbeat.ycp
 * Package:	Configuration of heartbeat
 * Summary:	Heartbeat settings, input and output functions
 * Authors:	Martin Lazar <mlazar@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of heartbeat.
 * Input and output routines.
 */

{

module "Heartbeat";
textdomain "heartbeat";

import "Progress";
import "Report";
import "Summary";
import "Service";

import "Mode";
import "PackageSystem";

global map config = $[];
global map authkeys = $[];
global map resources = $[];
global string ha_dir = "/etc/ha.d";
global boolean start_daemon = false;
global boolean start_daemon_modified = false;
global boolean resources_modified = false;
global boolean firstrun = false;

/**
 * Prototypes
 */
global boolean Modified();

/**
 */
global boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = Modified;

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
	return AbortFunction () == true;
    }
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    return resources_modified || config["modified"]:false 
	|| authkeys["modified"]:false || start_daemon_modified;
}

// Settings: Define all variables needed for configuration of heartbeat
// TODO FIXME: Define all the variables necessary to hold
// TODO FIXME: the configuration here (with the appropriate
// TODO FIXME: description)
// TODO FIXME: For example:
//   /**
//    * List of the configured cards.
//    */
//   list cards = [];
//
//   /**
//    * Some additional parameter needed for the configuration.
//    */
//   boolean additional_parameter = true;

/**
 * Read all heartbeat settings
 * @return true on success
 */
global boolean Read() {

    /* Heartbeat read dialog caption */
    string caption = _("Initializing Heartbeat Configuration");

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", 4, [
	    _("Read previous settings"),
	    _("Read resources"),
	    _("Read authentication keys"),
	    _("Read daemon status")

	], [
	    _("Reading previous settings..."),
	    _("Reading resources..."),
	    _("Reading authentication keys..."),
	    _("Reading daemon status..."),
	    _("Finished")
	],
	""
    );

    Progress::NextStage();
    
    // check installed packages
    if (!Mode::test() && !PackageSystem::CheckAndInstallPackagesInteractive(["heartbeat"]))
    {
	return false;
    }
    
    if(SCR::Read(.target.size, ha_dir + "/ha.cf") > 0) {

	foreach(string key, [ "debugfile", "logfile", "logfacility", "keepalive", "deadtime", "warntime",
	    "initdead", "udpport", "baud", "auto_failback", "hopfudge", "deadping", "watchdog",
	    "hbgenmethod", "realtime", "debug", "autojoin", "crm" ],
	{
	    list vals = (list)SCR::Read(topath(sformat(".etc.ha_d.ha_cf.\"%1\"", key)));
	    if (size(vals)>0) {
		config[key] = vals[size(vals)-1]:"";
	        y2milestone("%1  = '%2'", key, config[key]:"");
	    }
	});

	foreach(string key, ["serial", "bcast", "node", "ping", "stonith", "stonith_host", "ping_group",
	    "respawn", "apiauth", "ucast", "mcast"], 
	{
	    list<string> vals = (list<string>)SCR::Read(topath(sformat(".etc.ha_d.ha_cf.\"%1\"", key)));
	    if (size(vals)>0) {
		list u = [];
		foreach(string s, vals, {
//		    list<string> l = splitstring(s, " \t");
//		    l = filter(string s, l, { return s != ""; });
		    u = add(u, s);
//		    y2milestone("%1  = (%2)", key, mergestring(l, ", "));
		});
		config[key] = u;
	    }
	});
    } else {
	firstrun = true;

	list aa = [];
	aa = add(aa, "mgmtd uid=hacluster,root");
	aa = add(aa, "evms uid=hacluster,root");
	config["apiauth"] = aa;

	list rs = [];
	map unamemap = (map)SCR::Execute(.target.bash_output, "uname -m");
	string machine = deletechars(unamemap["stdout"]:"", "\n");
	if (machine == "x86_64") {
	    rs = add(rs, "root /usr/lib64/heartbeat/mgmtd -v");
	} else {
 	    rs = add(rs, "root /usr/lib/heartbeat/mgmtd -v");
	}
	rs = add(rs, "root /sbin/evmsd");
	config["respawn"] = rs;

	list bc = [];
	bc = add(bc, "eth0");
	config["bcast"] = bc;

	config["autojoin"] = "any";
	config["crm"] = "true";
    }
    config["modified"] = false;

    if(Abort()) return false;
    Progress::NextStage();
    if(SCR::Read(.target.size, ha_dir + "/haresources") > 0) {

	list<string> nodes = SCR::Dir(.etc.ha_d.haresources);
	foreach(string node, nodes, {
	    string r = (string)SCR::Read(topath(sformat(".etc.ha_d.haresources.\"%1\"", node)));
	    y2milestone("readed resource %1(%2)", node, r);
	    resources = add(resources, node, splitstring(r, " \t"));
	});
    }
    resources_modified = false;
    

    if(Abort()) return false;
    Progress::NextStage();
    if(SCR::Read(.target.size, ha_dir + "/authkeys") > 0) {

	string id = (string)SCR::Read(.etc.ha_d.authkeys.auth);
	if (id != nil && regexpmatch(id, "^[0-9]+$")) {
    	    string opt = (string)SCR::Read(topath(sformat(".etc.ha_d.authkeys.\"%1\"", id)));
	    list tok = regexptokenize(opt, "^[ \t]*([^ \t]+)[ \t]*(.*)$");
	    authkeys = $[ "id":id, "method":tok[0]:"", "password":tok[1]:""];
	}
    }
    authkeys["modified"] = false;

    if(Abort()) return false;
    Progress::NextStage();
    start_daemon = Service::Enabled("heartbeat");
    start_daemon_modified = false;

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();

    if(Abort()) return false;
    return true;
}

/**
 * Write all heartbeat settings
 * @return true on success
 */
global boolean Write() {

    /* Heartbeat read dialog caption */
    string caption = _("Saving Heartbeat Configuration");

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", 4, [
	    _("Write settings"),
	    _("Write resources"),
	    _("Write authentication keys"),
	    _("Restart services")
	], [
	    _("Writing settings..."),
	    _("Writing resources..."),
	    _("Writing authentication keys..."),
	    _("Restarting services..."),
	    _("Finished")
	],
	""
    );

    if(Abort()) return false;
    Progress::NextStage();

    /* Write ha.cf */
    if (config["modified"]:false) {
        if(SCR::Read(.target.size, ha_dir + "/ha.cf") < 0)
	    SCR::Write(.target.string, ha_dir + "/ha.cf", "");

        foreach(string key, [ "debugfile", "logfile", "logfacility", "keepalive", "deadtime", "warntime",
    	    "initdead", "udpport", "baud", "auto_failback", "watchdog", "hopfudge", "deadping",
	    "hbgenmethod", "realtime", "debug", "autojoin", "crm" ],
	{
//	    if (config[key]:nil != nil) {
        	y2milestone("write %1  = '%2'", key, config[key]:"");
    	        SCR::Write(topath(sformat(".etc.ha_d.ha_cf.\"%1\"", key)), 
		    config[key]:nil != nil ? [ config[key]:nil ] : nil );
//	    }
	});


        foreach(string key, [ "serial", "bcast", "mcast", "ucast", "stonith", "stonith_host", "node", 
    	    "ping", "ping_group", "respawn", "apiauth"], 
	{
//          SCR::Write(topath(sformat(".etc.ha_d.ha_cf.\"%1\"", key)), nil);
//	    if (size(config[key]:[]) > 0) {
		list<string> l = config[key]:[];
        	y2milestone("write %1  = [%2]", key, mergestring(l, ", "));
    		SCR::Write(topath(sformat(".etc.ha_d.ha_cf.\"%1\"", key)), 
		    size(l) > 0 ? l : nil);
//	    }
	});
	SCR::Write(.etc.ha_d.ha_cf, nil);
    }


    if(Abort()) return false;
    Progress::NextStage();

    /* Write haresources */
    if (resources_modified) {
	if(SCR::Read(.target.size, ha_dir + "/haresources") < 0)
	    SCR::Write(.target.string, ha_dir + "/haresources", "");


	foreach(string key, SCR::Dir(.etc.ha_d.haresources), {
	    SCR::Write(topath(sformat(".etc.ha_d.haresources.\"%1\"", key)), nil);
	});
	
	foreach(string node, list r, (map<string,list>)resources, {
	    string opt = mergestring((list<string>)r, " ");
	    if (opt == "") opt = nil;
	    SCR::Write(topath(sformat(".etc.ha_d.haresources.\"%1\"", node)), opt);
    	    y2milestone("writed resource %1(%2)", node, opt);
	});
        SCR::Write(.etc.ha_d.haresources, nil);
    }

    if(Abort()) return false;
    Progress::NextStage();
    
    /* Write authkeys */
    if(authkeys["modified"]:false) {
	if(SCR::Read(.target.size, ha_dir + "/authkeys") < 0)
	    SCR::Write(.target.string, ha_dir + "/authkeys", "");

	string id = authkeys["id"]:"1";
	string opt = authkeys["method"]:"crc" + " " + authkeys["password"]:"";
	SCR::Write(.etc.ha_d.authkeys.auth, id);
    	SCR::Write(topath(sformat(".etc.ha_d.authkeys.\"%1\"", id)), opt);
    	SCR::Write(.etc.ha_d.authkeys, nil);
        y2milestone("writed authkeys %1 %2", id, opt);
    } else if (SCR::Read(.target.size, ha_dir + "/authkeys") < 0) {
	SCR::Write(.target.string, ha_dir + "/authkeys", "");
	SCR::Write(.etc.ha_d.authkeys.auth, "1");
	SCR::Write(.etc.ha_d.authkeys."1", "crc");
    }
    SCR::Execute(.target.bash, "/bin/chown 0.0 " + ha_dir + "/authkeys");
    SCR::Execute(.target.bash, "/bin/chmod 0600 " + ha_dir + "/authkeys");

    if(Abort()) return false;
    Progress::NextStage();
    
    /* Restart services */
    if (!start_daemon) {
	Service::Stop("heartbeat");
        if (! Service::Disable("heartbeat")) {
	    Report::Error(Service::Error());
        }
    } else {
	if (! Service::Enable("heartbeat")) {
            Report::Error(Service::Error());
        }	
	Service::Restart("heartbeat");
    }


    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();

    if(Abort()) return false;
    return true;
}

/**
 * Get all heartbeat settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
    // TODO FIXME: your code here (fill the above mentioned variables)...
    return true;
}

/**
 * Dump the heartbeat settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
    // TODO FIXME: your code here (return the above mentioned variables)...
    return $[];
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary() {
    // TODO FIXME: your code here...
    /* Configuration summary text for autoyast */
    return [ _("Configuration Summary..."), [] ];
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global list Overview() {
    // TODO FIXME: your code here...
    return [];
}

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages() {
    // TODO FIXME: your code here...
    return $[ "install":["heartbeat"], "remove":[""] ];
}

/* EOF */
}
